package org.usfirst.frc.team360.robot;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.buttons.Button;
import edu.wpi.first.wpilibj.buttons.JoystickButton;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.DoubleSolenoid;
//import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.Compressor;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
//tank drive 2 Joysticks, left trigger engages down speed right trigger activates up speed
public class Robot extends IterativeRobot {
	RobotDrive myRobot;
	VictorSP liftMotor;
	Joystick stickR;
	Joystick stickL;
	Joystick gamePad; 
	
	
	
	
	int autoLoopCounter;
	int totes; //num of totes carried
	boolean grab;
	boolean release; 
	boolean up;
    boolean down;
	double stickPos = 1;
	double Dgain = 0.011;
    double Pgain = 0.45;
    double Igain = 0.024;//.012
    double error;
    double last_error = 0;
    double Padjustment;
    double Dadjustment;
    double PID_adjust;
    boolean deployPrep;
	//double joyR = stickR.getRawAxis(1);
	//double joyL = stickL.getRawAxis(1);
	//double Intake = gamePad.getRawAxis(2);
	public static boolean halfSpeed;
	DoubleSolenoid intakeSol = new DoubleSolenoid(0, 1);
	Compressor compressor = new Compressor(0);//init compressor and maps it
	
	

	
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */

	
	
    public void robotInit() {
    	myRobot = new RobotDrive(0,1);
    	myRobot.setExpiration(0.1);
    	stickR = new Joystick(1); 
    	stickL = new Joystick(0);
    	gamePad = new Joystick(2);
    	halfSpeed = true; 
        
    }
   
    public void disabledInit() {
    	compressor.stop();
    	//set percent to 0

    }
    
    public void autonomousInit() {
    	compressor.start();
    	autoLoopCounter = 0;
    }

    /**
     * This function is called periodically during autonomous
     */
   
	public void autonomousPeriodic() {
    	
    }
    
    /**
     * This function is called once each time the robot enters tele-operated mode
     */
    
	public void teleopInit(){
		 compressor.start();
    }

    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
    	
    	up = stickR.getRawButton(1);
        down = stickL.getRawButton(1);
        grab = gamePad.getRawButton(1);
        release = gamePad.getRawButton(2);
        double joyR = stickR.getRawAxis(1);
        double joyL = stickL.getRawAxis(1); 
    	//myRobot.tankdrive(joyR, joyL);
        /*
         * 
         */
      	//myRobot.tankDrive(-joyR, joyL); 
      	intakeControl();
           Timer.delay(0.005); // wait for a motor update time
        if(up == true && down == false) {
        	//shiftUp();
        		
        		halfSpeed = true;
        		System.out.println("speed = high");
        		//myRobot.tankDrive(0.9, 0.9);
        		
        	
        	
        }
        if(down == true && up == false){
        	//shiftDown();
        	
               halfSpeed = false;
               //myRobot.tankDrive(0.8, 0.8);
              	System.out.println("speed = low");
               
        }
        if (halfSpeed == false){
        	Timer.delay(0.005);
        	joyR *= .95;
        	joyL *= .95;
        	myRobot.tankDrive(joyR, -joyL);
        } else if (halfSpeed == true){
        	
        	joyR *= .7;
        	joyL *= .7;
        	Timer.delay(0.005);
        	myRobot.tankDrive(-joyR, joyL);
        }
    }  
    public void intakeControl() {
    		grab = gamePad.getRawButton(7);
    		release = gamePad.getRawButton(8);   		       
    		
    		if (grab==true && release == false)
            {
                intakeSol.set(DoubleSolenoid.Value.kForward);//grab
                System.out.println("solenoid = forward");
            } 
            else if (release==true && grab == false) 
            {
                intakeSol.set(DoubleSolenoid.Value.kReverse);//release
                System.out.println("solenoid = reverse");
            }
   }
    public void liftControl() {
    	/* call liftControl from teleop periodic
    	 get encoder value
    	 hardcode the target for now for testing - always do Lift routine to same spot, eg. 1000
    	 doPID(1, 0 , 0.15, 0.01, armPosition->GetValue(), armTarget);   //performs PID output. PID coefficients = 1, 0, 0.15 respectively; time to differentiate = 1 ms; reads position from potentiometer; target angle
	
		output = output / 100;                                          //scales output back by 100 since the potentiometer says a few hundred counts equals less than 100 degrees in RL
		
		if(output > 1){ output = 1;}                                    //these two lines set the output to max should it exceed the max
		if(output < -1){ output = -1;}
		
		below is where set motor speed to output from PID
		use correct Java syntax for this
		you will need to define the motor, too.
		just copy the driver motor definitions in the same sections that they are done
		you will also need to initialize the encoder counts to 0 somewhere, like in teleopInit
		arm -> Set(output); */
    }
    public void doPID(float P, float I, float D, float dt, int position, int setPoint){ //arm to left is less than 470; to the right greater than 470
	/*	you need to translate this into Java syntax and declare your variables
	    I think the output is the speed
	    Wait(dt);
		error = position - setPoint;
		integral = integral + (error * dt);
		derivative = (error - prevError) / dt;
		output = (P * error) + (I * integral) + (D * derivative);
		prevError = error;
		*/
	}
    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
    	LiveWindow.run();
    }
    public void deployStack(){
    
   
    }
}